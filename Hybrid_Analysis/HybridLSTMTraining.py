#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Dec 7 18:05:27 2020

@author: hallavar
"""

import sys
sys.path.append('../')
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'  # supprime les différents avertissements de version de TensorFlow
#os.environ['CUDA_VISIBLE_DEVICES'] = '-1' #A mettre si on veut forcer l'execution sur le CPU
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.layers import Dense, Dropout, Masking, LSTM
from common import load_firstlayer_data, create_secondlayer_partition, DataGenerator, get_test_data, Binary_Classification, get_metrics

Istlayer_dataset_path = "E:/pfe/CICInvesandMal2019/Analysis-CSV/Other_CSVs/1st_Layer/" #Emplacement du CSV contenant les paramètres statiques
Snd_layer_data_path = 'E:/pfe/CICAndMal2017/' # Emplacement du dossiers contenants les captures réseaux

train_samples, train_labels=load_firstlayer_data(Istlayer_dataset_path, data='Testing') #Chargement des données statique d'entrainement du premier modeèle

model_static = Sequential()

model_static.add(Dense(units=8111, activation='relu')) # Il y a 8111 parametres statiques pour chaque applications
model_static.add(Dense(units=256, activation='relu'))
model_static.add(Dense(units=128, activation='relu'))
model_static.add(Dense(units=64, activation='relu'))
model_static.add(Dense(units=1, activation='sigmoid')) # On veut que le modele nous renvoie qu'une seule valeure

model_static.compile(optimizer='adam',loss='binary_crossentropy',metrics='accuracy')
model_static.fit(train_samples, train_labels, epochs=10) #On entraine le modèle sur 10 epoch

static_df=pd.read_csv(Istlayer_dataset_path+'StaticLayer_Intent_and_Permission_Bening&malware_'+'Training'+'Smaples.csv') #On charge les données statiques pour le reste des applications
static_df=static_df.drop_duplicates(['<MD5>'])# On supprime les applications en doublons
temp=static_df.drop(['Binary_Type','<family>','<category>', '<MD5>'], axis=1)# On supprimme les colonnes ininteressantes pour notre classification
static_df['Static prediction']=model_static.predict(temp)# Pour chaque application, on réalise la prédiction avec le premier modele

partition, test = create_secondlayer_partition(Istlayer_dataset_path,Snd_layer_data_path,5/6,1/6) #dicise l'ensemble d'applications restant en 3, un jeu d'entrainement et un jeu de validation pour le modèle hybride et un jeu de test Global

dic=pd.read_csv('Dynamic_features_statistics.csv', index_col=0)#On charge les differentes valeurs statistique du jeu de données dynamique afin de normalisé les données
dic=dic.to_dict()

training_generator = DataGenerator(partition['train'], static_df, max_values=dic, batch_size=32, padding=None)#On crée un générateur de donnée d'entrainement hybride
validation_generator = DataGenerator(partition['validation'], static_df, max_values=dic, batch_size=64, padding=None)#On crée un générateur de donné de validation hybride

special_value= -1.0#On indique la valeur du padding

model = Sequential()#On initialise le modèle dynamique
#model.add(Masking(mask_value=special_value, batch_input_shape = (None, None, 71)))#On rajoute une couche de masque afin de supprimer les ligne de padding
model.add(LSTM(64, return_sequences=True))
model.add(Dropout(rate=0.2))
model.add(LSTM(32))
model.add(Dropout(rate=0.2))
model.add(Dense(5, activation='softmax'))#Notre probleme est une classification en 5 familles d'applications
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
#es_callback = EarlyStopping(monitor='val_loss', patience=25)
history = model.fit(x = training_generator, validation_data = validation_generator, epochs=300, verbose=1)#Entrainement du modèle hybride

#Réalisation des courbes d'entrainements
loss = history.history['loss']
val_loss = history.history['val_loss']

epochs = range(1, len(loss) + 1)

plt.plot(epochs, loss, 'bo', label='Training loss')
plt.plot(epochs, val_loss, 'r', label='Validation loss')
plt.title('Training and validation loss')
plt.legend()

plt.show()

    
test_samples, test_labels = get_test_data(test, static_df, dic, Snd_layer_data_path)#Création des données de test

static_prediction=[u[0][70] for u in test_samples]#Extraction de la premiere prédiction statique

static_prediction=np.round(np.asarray(static_prediction))#Transormation en label prédit

hybrid_prediction=model.predict(test_samples)#Prédiction hybride

hybrid_prediction = Binary_Classification(hybrid_prediction)#Transormation de la prédiction multiclasse en prédiction binaire

test_labels = Binary_Classification(test_labels)#Transformation du label multiclasse en label binaire

print(get_metrics(test_labels,static_prediction, get_cm=True))#Matrice de confusioon du premier modele statique
print(get_metrics(test_labels,hybrid_prediction, get_cm=True))#Matrice de confusion du modèle hybride